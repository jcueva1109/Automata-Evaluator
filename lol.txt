        codigo basura
--------------------------------
        
        print("Alphabet: ",data["alphabet"])
        print("States: ",data["states"])
        print("Initial States: ",data["initial_state"])
        print("Final States: ",data["accepting_states"])
        print("Transitions: ",data["transitions"])


        print("Alphabet: ",alphabet)
        print("States: ",states)
        print("Initial States: ",initial_state)
        print("Final States: ",accepting_states)
        print("Transitions: ",transitions)

---------------------------------
class NFA:
    def __init(self):
        pass

    def nfa_evaluate(self, alphabet, states, initial_state, accepting_states, transitions, str_test):
        current_state = initial_state
        final = True

        for char_index in range(len(str_test)):
            current_char = str_test[char_index]
            existe = True       

            for t in transitions:
                if current_state == t[0] and current_char == t[1]:
                    current_state = t[2]
                    existe = False
                    break
            if existe:
                final = False
                break

        if current_state in accepting_states and final:
            print("Pertenece a L(M)")
        else:
            print("No pertenece a L(M)")
        pass
    
    def union(self, states):
        return tuple(states)
        pass

    def nfa2dfa(self, alphabet, states, initial_state, accepting_states, transitions, str_test):

        current_state = initial_state

        for alpha in alphabet:
            _input = alpha[0]
            print("Input: ", _input)

        print("\n")
        for char_index in range(len(str_test)):
            current_char = str_test[char_index]
            for t in transitions:
                if current_state == t[0] and _input == t[1]:
                    union(t)
                    print(union(t))
        pass

------------------
class NFA: 
    def __init__(self):
        self.
        pass

    def init_states(self):
        self.states = list(range(self.states))
    
---------------------------

for index in _input:
            if _input[index] == alfabeto[0]:
                for i in states:
                    res = list(map(" ".join, states))
                    print("Diosito pofavo: ", res)

["A","0","A"],
["A","2","A"],
["A","0","B"],

alphabeto= 0,1,2

[a]
res=[a]
funca(xx,transiciones,alfabeto):
    res=[[A,B],[/],[A]]
    for a in alfato:
        tr=[]      
        for t in transiciones:
            for x in xx:
            if t[0]==x and t[1]==a:     hay una transicion
                tr.append(t[2])             guardo a donde me lleva 
        
        if len(tr)==0:
            tr.append("/")

        res.append(tr)
return [xx,res]     estado y sus transiciones
[A,[[A,B],[/],[A]]]


##ejemplo##
        #         0       1       2
        # [a,       [[a,b],  a,    c]]
        # [[a,b]    [a, ab]


------------------------

for x in nfaTable:      #estados
            for y in x[1]:
                if y not in x[0]:       #transiciones
                    # CREAR LA COMBI
                    res = self.union(alpha, x, y)
                    #nfaTable.append(mandas la combi)
                    nfaTable.append(res)

        print("se guardo a la tabla, osea que el union esta bien")
        for x in nfaTable:

            if x[0] not in states:
                states.append(x[0])

            for i in range(len(alpha)):
                tran=[x[0],alpha[i],x[1][i]]
                if x[1][i] not in states:
                    states.append(x[1][i])

                if tran[2] != "/":
                    transitions.append(tran)

        for x in states:
            for y in a_stat:
                if y in x:
                    accepting_states.append(x)

        print("Alphabet: ",alphabet)
        print("States: ",states)
        print("Initial States: ",initial_state)
        print("Final States: ",accepting_states)
        print("Transitions: ",transitions)